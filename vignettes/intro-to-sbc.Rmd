---
title: "Introduction to the SBC package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro-to-sbc}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(sbcrs)
library(rstan)
```

```{r include = FALSE, echo = FALSE, message = FALSE}
rstan::rstan_options("auto_write" = TRUE)
get_compiled_stan_model <- function(filename) {
  m <- NULL
  stan_file_loc <- here::here('inst', 'stan', filename)
  if (file.exists(stan_file_loc)) {
    m <- stan_model(file = stan_file_loc, save_dso = TRUE)
  }
  if (is.null(m)) {
    m <- stan_model(file = system.file('stan', filename, package = 'sbcrs'))
  }
  m
}
my_model <- get_compiled_stan_model('normal_group_means.stan')
```


## Stan model

We want to validate a Stan model. The Stan model used in this example has matrix, vector, and scalar parameters. The modeled variables `y` have means and standard deviations that vary by `group` and `type`.

```{r eval = TRUE, output = 'as_is', echo = FALSE, comment = ""}
cat(readr::read_file(system.file('stan', 'normal_group_means.stan', package = 'sbcrs')))
```

Compile the Stan model.

```{r eval = FALSE}
my_model <- stan_model(file = system.file('stan', 'normal_group_means.stan', package = 'sbcrs'))
```

## Validating the model via simulation-based calibration with rank statistics

To validate the model using the SBC package, we need to define four functions. These functions must have signatures matching those specified in `help('SBC', package = 'sbcrs')` (under `$new(data, params, modeled_variable, sampling)`).

### Define functions

#### Data

The first function generates a named list with a new (possibly random) data set. All of the variables defined in the Stan model's `data` section must be represented in this list, except:

* Variables given an explicit value in the `data` section

* Variables modeled probabilistically in the `model` section (these are generated by the `modeled_variable` function described below).

```{r}
gen_data <- function(seed) {
  set.seed(seed + 1e6)
  n_obs <- 100
  n_groups <- 5
  n_types <- 3
  group <- sample.int(n_groups, size = n_obs, replace = TRUE)
  type <- sample.int(n_types, size = n_obs, replace = TRUE)
  list(n_obs = n_obs, n_groups = n_groups, n_types = n_types, group = group, type = type)
}
```

The parameter `seed` in `gen_data` is used to set the random seed. It is important to set the random seed in all four functions, otherwise the rank statistics will be biased. Moreover, because the same value of `seed` is passed to all four functions, it is good practice to add an offset when setting the seed.

#### Parameters

Generate random parameters (excluding the modeled variable) from the prior distributions indicated in the Stan model.

```{r}
gen_params <- function(seed, data) {
  set.seed(seed + 2e6)
  sigma <- rexp(data$n_types)
  mu <- matrix(rnorm(data$n_groups * data$n_types, 0, 1), 
               nrow = data$n_groups)
  nu  <- rnorm(1)
  list(sigma = sigma, mu = mu, nu = nu)
}
```

#### Modeled parameter

Generate the modeled parameterâ€”the one that is defined in the `data` section of the Stan model and modeled probabilistically in the `model` section. This parameter needs to be generated from the same likelihood (conditional on the model parameters) indicated by the Stan model.

```{r}
gen_modeled_variable <- function(seed, data, params) {
  set.seed(seed + 3e6)
  y_mean <- purrr::map2_dbl(data$group, data$type, ~params$mu[.x, .y])
  y_sd <- params$sigma[data$type]
  list(y = rnorm(data$n_obs, y_mean, y_sd))
}
```

#### Sampling

Define a function to draw samples from the Stan model. This function ties together the Stan model `my_model` and the lists returned by the functions defined above. When calling `rstan::sampling`, pass in a list concatenated from the `data` and `modeled_variable` lists.

```{r}
sample_from_model <- function(seed, data, params, modeled_variable, iters) {
  data_for_stan <- c(data, modeled_variable)
  rstan::sampling(my_model, data = data_for_stan, seed = seed,
                  chains = 1, iter = 2 * iters, warmup = iters, 
                  open_progress = FALSE, show_messages = FALSE,
                  refresh = 1000)
}
```

### Initialize a new calibration object

To create a new calibration object, call `SBC$new()` passing in references to the functions defined above.

```{r}
my_sbc <- SBC$new(data = gen_data, 
                  params = gen_params, 
                  modeled_variable = gen_modeled_variable, 
                  sampling = sample_from_model)
```

### Calibration

To run the calibration routine, call the `$calibrate()` method on `my_sbc`. It will update the fields in this object with the output of the calibration routine.

```{r include = FALSE}
doParallel::registerDoParallel(cores = (if (interactive()) parallel::detectCores() else 2))
my_sbc$calibrate(N = 32, L = 20, keep_stan_fit = FALSE)
```

The results of the calibration routine are now stored in the `$calibrations` field. This is a list of length `N = 8`. It contains the data and parameters generated for each. If `keep_stan_fit = TRUE`, then it also stores the `stan_fit` objects. This can be memory-intensive, but also useful for debugging. 

Each calibration in `$calibrations` also contains a named list called `$ranks`. Each parameter `var` has a corresponding named entry called `$ranks$var`, whose value is the number of samples (out of a maximum `L`) for which the sampled value of `var` was less than `params$var`. 

```{r}
purrr::map(my_sbc$calibrations, 'ranks')[1:3]
```

If the generating functions defined above match the Stan model, then these ranks should be uniformly distributed. That is, deviations from uniformity indicate the generating functions in R, the stan model, or both are misspecified.

A quick summary of the calibrations compares the rank statistics to typical inner quantiles.

```{r}
my_sbc$summary()
```

When the number of parameters, `N`, or `L` are small, these estimates are noisy.

To visualize the ranks and compare them against typical inner quantiles, use the `plot` function. 

```{r}
my_sbc$plot()
```

Passing in the name of one or more parameters to the `plot` or `summary` functions yields statistics calculated only for those parameters. 

```{r}
my_sbc$plot(c('nu', 'sigma'))
my_sbc$summary('sigma')
```


## Flexibly testing families of models

Because our Stan model allows the number of `types` and `groups`  to vary, we would ideally test the model using different values of `n_types` and `n_groups`. Or, to understand how well the model scales with the number of observations, we might want to test different values of `n_obs`. To accomplish this, we can create a function that returns a data-generating function with different values of these three inputs.

```{r}
new_gen_data_function <- function(.n_obs, .n_groups, .n_types) {
  function(seed) {
    set.seed(seed + 1e6)
    n_obs <- .n_obs
    n_groups <- .n_groups
    n_types <- .n_types
    group <- sample.int(n_groups, size = n_obs, replace = TRUE)
    type <- sample.int(n_types, size = n_obs, replace = TRUE)
    list(n_obs = n_obs, n_groups = n_groups, n_types = n_types, group = group, type = type)
  }
}
```

We can similarly wrap the creation of a new SBC object in a generating function.

```{r}
new_sbc_object <- function(n_obs, n_groups, n_types) {
  gen_data <- new_gen_data_function(n_obs, n_groups, n_types)
  SBC$new(data = gen_data, 
          params = gen_params, 
          modeled_variable = gen_modeled_variable, 
          sampling = sample_from_model)
}
```

1 group and 1 type, zero observations

```{r}
sbc <- new_sbc_object(n_obs = 0, n_groups = 1, n_types = 1)
sbc$calibrate(N = 32, L = 20, keep_stan_fit = FALSE)
sbc$plot()
sbc$summary()
```

1 group and 1 type, 100 observations

```{r}
sbc <- new_sbc_object(n_obs = 100, n_groups = 1, n_types = 1)
sbc$calibrate(N = 32, L = 20, keep_stan_fit = FALSE)
sbc$plot()
sbc$summary()
```

2 groups and 8 types, 200 observations

```{r}
sbc <- new_sbc_object(n_obs = 200, n_groups = 2, n_types = 8)
sbc$calibrate(N = 32, L = 20, keep_stan_fit = FALSE)
sbc$plot()
sbc$summary()
```





